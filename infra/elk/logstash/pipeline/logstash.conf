input {
  jdbc {
    jdbc_driver_library => "/usr/share/logstash/tools/mysql-connector-j-9.1.0.jar"
    jdbc_driver_class => "com.mysql.cj.jdbc.Driver"
    jdbc_connection_string => "jdbc:mysql://host.docker.internal:3306/tubelens?useSSL=false&serverTimezone=UTC"
    jdbc_user => "root"
    jdbc_password => "991209"
    statement => "SELECT * FROM trending_video WHERE updated_at > :sql_last_value"
    schedule => "*/1 * * * *"
    use_column_value => true
    tracking_column => "updated_at"
    tracking_column_type => "timestamp"
    record_last_run => true
    last_run_metadata_path => "/usr/share/logstash/data/.logstash_jdbc_last_run"
  }
}

filter {
  ruby {
    code => '
      require "nokogiri"
      require "open-uri"

      title = event.get("title").to_s

      # 어절 단위로 나누기 (띄어쓰기 기준)
      words = title.split(" ")

      # 조사/불용어 제거용 패턴 (정규표현식으로 어절의 끝에 붙은 조사 제거)
      stopwords = %w(이 가 을 를 은 는 도 에 와 과 의 로 으로 에게 한 까지 부터 만 마저 조차 보다 처럼 같이 등 의해서)

      # 의미 없는 단어 및 접미사 필터링
      suffixes = %w(으로 만 게)

      # 명사 추출 (단순히 동사를 제외한 일반 명사 추출을 목표로 함)
      nouns = words.select do |word|
        # 조사 제거
        cleaned_word = word
        stopwords.each do |josa|
          # 단어 끝에 조사 있는지 확인 후 제거
          cleaned_word = cleaned_word.sub(/#{josa}\z/, "") if cleaned_word.end_with?(josa)
        end
        # 접미사 제거
        suffixes.each do |suffix|
          cleaned_word = cleaned_word.sub(/#{suffix}\z/, "") if cleaned_word.end_with?(suffix)
        end
        # 명사인 단어만 선택 (예시로 길이가 2글자 이상인 단어만 선택)
        cleaned_word.length > 1 && !cleaned_word.empty? && cleaned_word !~ /[ㅏ-ㅣ]/ # 이모티콘, 동사/형용사 제외
      end

      # 특수기호 제거
      cleaned_nouns = nouns.map { |noun| noun.gsub(/[^[:alpha:]\p{Hangul}]/, "") }

      # 빈값 제거 + 중복 제거
      keywords = cleaned_nouns.reject { |w| w.empty? }.uniq

      # suggest 필드에 설정
      event.set("[suggest][input]", keywords)
    '
  }
}

output {
  elasticsearch {
    hosts => ["elasticsearch:9200"]
    index => "tubelens_video"
    document_id => "%{id}"
    action => "update"
    doc_as_upsert => true
  }
}